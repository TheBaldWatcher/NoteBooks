[[toc]]



# 图

```c++
// N个农场，每个农场可以生产《=2单位的作物、并总要消耗1单位作物。求给每个农场分配1单位作物的最小成本
// 运输成本di, 生产成本gi
// 测例，答案
// 2 3 1 5 5
// 3 100 100 1 2 3 6
// 4 1 2 3 1 1 100 100 12
// 48 7 2 19 18 4 14 9 16 4 18 3 16 15 8 13 15 15 9 9 5 1 18 11 11 14 7 11 18 6 10 2 12 11 11 16 11 7 4 1 18 16 5 15 7 8 1 19 14 20 14 4 3 4 9 13 11 14 10 14 12 18 5 20 5 6 9 8 1 13 15 19 11 9 14 16 14 5 20 17 10 2 8 17 6 2 2 17 10 15 19 1 2 2 2 6 445
// 96 14 17 18 1 14 12 3 19 17 8 3 12 15 1 18 9 18 20 19 1 18 8 10 2 5 17 2 15 13 17 5 11 12 14 6 2 6 18 11 19 16 1 18 13 7 17 14 11 19 4 12 19 7 1 11 15 7 9 3 8 13 14 19 3 13 19 9 13 1 18 13 17 9 16 12 1 13 17 15 16 2 4 1 12 7 6 1 11 15 4 20 9 19 7 8 18 1 16 4 8 5 11 10 9 19 13 17 14 7 11 19 1 15 2 12 9 8 9 10 15 2 9 9 6 12 4 2 20 20 7 2 9 12 7 10 5 20 17 16 18 11 1 15 2 4 10 12 17 3 17 8 18 2 5 11 4 5 3 8 20 9 11 1 12 10 5 18 8 14 2 7 3 7 11 10 7 10 13 5 15 15 6 15 1 5 4 2 3 9 13 3 796
// 90 19 1 1 8 15 6 5 4 3 7 18 17 8 2 18 20 14 6 7 3 8 6 10 11 18 8 16 16 10 12 2 2 17 17 6 15 8 4 6 16 11 20 6 10 19 1 11 7 3 19 1 2 13 8 4 18 8 14 5 11 13 20 14 18 4 3 3 15 11 14 18 9 16 1 8 19 10 16 5 20 2 20 1 18 7 7 3 12 1 2 8 4 4 2 10 11 2 12 12 14 20 18 19 19 18 17 15 18 19 7 1 6 8 11 15 18 4 1 16 18 12 16 9 7 18 4 20 7 7 2 4 10 12 16 12 10 14 18 5 16 6 11 16 13 11 2 17 11 16 12 8 12 13 1 14 5 3 12 2 13 17 10 20 3 20 17 5 14 7 14 1 4 11 7 20 8 14 6 7 848
// 87 13 15 1 18 16 5 14 14 8 6 15 12 13 1 4 9 3 3 15 1 4 10 11 10 19 4 9 8 13 11 2 5 6 11 17 11 7 20 9 20 2 7 10 2 2 2 18 10 18 14 14 9 12 12 17 3 20 5 13 8 16 16 12 3 1 1 10 5 19 14 11 13 15 8 9 15 15 13 18 1 3 17 18 8 1 9 8 16 16 8 17 4 18 4 4 14 17 5 11 18 19 2 1 18 13 14 15 12 10 1 16 8 7 1 7 5 13 2 7 18 20 11 11 1 4 8 17 7 13 8 14 14 11 6 16 4 13 20 12 13 11 17 2 15 16 15 18 6 20 5 1 2 16 1 12 9 15 13 11 20 14 4 9 17 13 19 10 15 1 4 20 9 9 807

/**
 * 可以用图来解。最小费用流的变种。
 * * 最小费用流求的是从s到t，传输N流量时的最小费用。本题中传输的流量N的值为农场数
 * * 如何构造图
 *   * 每个农场相互连边
 *     * 容量为无穷，费用为d[i]
 *   * 本题中，每个农场都可以生产，相当于有多个源；可以构造个虚拟source节点，该节点向所有的农场连一条边：
 *     * 容量为2，费用为g[i]
 *   * 每个农场都可以消费，相当于有多个汇；可以构造个虚拟sink节点，所有农场向该节点连一条边：
 *     * 容量为无穷，费用为0
 *     * 由于每个农场至少要消耗1单位，因此容量有下限1，如何处理？：
 *       * 新加一条从农场到sink的边，容量为1，费用为-M，其中M为一个足够大的数
 *       * 旧的边容量减少1，本题中，仍为无穷。
 *       * 最后结果中，要加上M * 农场数
 * * 图构造好后，即和归约为最小费用流问题，正常求解即可
 */
struct Edge {
  int64_t to       = -1;
  int64_t capacity = 0;
  int64_t reverse  = 0;
  int64_t cost     = 0;
};

struct PrevNode {
  int64_t node = -1;
  int64_t edge = -1;
};

struct DistAndNode {
  int64_t dist = -1;
  int64_t node = -1;
};

struct MyGreater {
  bool operator()(DistAndNode const &lhs, DistAndNode const &rhs) const { return lhs.dist > rhs.dist; }
};

constexpr int64_t kMaxFarms    = 200'000;
constexpr int64_t kMaxDCost    = 1e9;
constexpr int64_t kUnreachable = kMaxFarms * kMaxDCost;
constexpr int64_t kMaxG        = 2;
constexpr int64_t kInf         = numeric_limits<int64_t>::max();
constexpr int64_t kM           = kMaxFarms * kMaxDCost / 10;  // a very huge number

using Edges = std::vector<Edge>;
using Graph = vector<Edges>;

void AddLine(int64_t from, int64_t to, int64_t capacity, int64_t cost, Graph *graph) {
  auto &from_node = (*graph)[from];
  auto &to_node   = (*graph)[to];
  auto to_size    = static_cast<int64_t>(to_node.size());
  auto from_size  = static_cast<int64_t>(from_node.size());
  from_node.push_back(Edge{.to = to, .capacity = capacity, .reverse = to_size, .cost = cost});
  to_node.push_back(Edge{.to = from, .capacity = 0, .reverse = from_size, .cost = -cost});
}

Graph BuildGraph(vector<int32_t> const &ds) {
  Graph graph;
  graph.reserve(ds.size() + 3);  // +2 for source and sink
  graph.emplace_back();
  for (int i = 0; i < static_cast<int>(ds.size()); ++i) {
    graph.emplace_back();

    AddLine(i, i + 1, kInf, ds[i], &graph);
    AddLine(i + 1, i, kInf, ds[i], &graph);
    // auto &from = graph[i];
    // auto &to   = graph[i + 1];
    // from.push_back(Edge{.to = i + 1, .capacity = 1, .cost = 0});
    // to.push_back(Edge{.to = i, .capacity = 0, .cost = 0});
  }
  return graph;
}

pair<int64_t, int64_t> ExtendWithMinFlow(vector<int32_t> const &gs, Graph *graph) {
  // add a pseudo source and a pseudo sink
  int64_t farms  = graph->size();
  int64_t source = graph->size();
  int64_t sink   = graph->size() + 1;

  graph->emplace_back();
  graph->emplace_back();
  // auto &source_node = (*graph)[source];
  // auto &sink_node   = (*graph)[sink];
  for (int i = 0; i < farms; ++i) {
    AddLine(source, i, kMaxG, gs[i], graph);

    AddLine(i, sink, kInf, 0, graph);
    AddLine(i, sink, 1, -kM, graph);  // 每个农场至少需要1单位
  }
  return {source, sink};
}

auto Dijkstra(int source, Graph *graph, vector<int64_t> *h) -> pair<vector<PrevNode>, vector<int64_t>> {
  auto ret = pair<vector<PrevNode>, vector<int64_t>>{
      vector<PrevNode>(graph->size(), {-1, -1}),
      vector<int64_t>(graph->size(), kUnreachable),
  };
  auto &prev   = ret.first;
  auto &dist   = ret.second;
  dist[source] = 0;

  priority_queue<DistAndNode, vector<DistAndNode>, MyGreater> pq;
  pq.push({.dist = 0, .node = source});
  while (!pq.empty()) {
    auto cur = pq.top();
    pq.pop();
    if (cur.dist > dist[cur.node]) {
      continue;  // already handled
    }
    for (int64_t i = 0; i < static_cast<int64_t>((*graph)[cur.node].size()); ++i) {
      auto &edge = (*graph)[cur.node][i];
      if (edge.capacity > 0) {
        int64_t new_dist = dist[cur.node] + edge.cost + (*h)[cur.node] - (*h)[edge.to];
        if (new_dist < dist[edge.to]) {
          dist[edge.to] = new_dist;
          prev[edge.to] = {.node = cur.node, .edge = i};
          pq.push({new_dist, edge.to});
        }
      }
    }
  }
  return ret;
}

int64_t MinCostFlow(int source, int sink, int flow, Graph *graph) {
  int64_t res = 0;
  vector<int64_t> h(graph->size(), 0);  //势
  while (flow > 0) {
    auto const &[prev, dist] = Dijkstra(source, graph, &h);

    if (dist[sink] == kUnreachable) {  // 不能再增广
      return -1;
    }
    for (size_t i = 0; i < graph->size(); ++i) {
      h[i] += dist[i];
    }
    int64_t d = flow;
    for (int v = sink; v != source; v = prev[v].node) {
      d = min(d, (*graph)[prev[v].node][prev[v].edge].capacity);
    }
    flow -= d;
    res += d * h[sink];
    for (int v = sink; v != source; v = prev[v].node) {
      Edge &e = (*graph)[prev[v].node][prev[v].edge];
      e.capacity -= d;
      (*graph)[v][e.reverse].capacity += d;
    }
  }
  int farms = graph->size() - 2;
  return res + kM * farms;
}

int main() {
  int n   = 0;
  int val = 0;
  while (cin >> n) {
    vector<int32_t> ds(n - 1, 0);
    vector<int32_t> gs(n);
    for (int i = 0; i + 1 < n; ++i) {
      cin >> val;
      ds[i] = val;
    }
    for (int i = 0; i < n; ++i) {
      cin >> val;
      gs[i] = val;
    }
    // cout << "ds:" << fmt::format("{}", fmt::join(ds, ",")) << "\n";
    // cout << "gs:" << fmt::format("{}", fmt::join(gs, ",")) << "\n";
    auto graph          = BuildGraph(ds);
    auto [source, sink] = ExtendWithMinFlow(gs, &graph);

    cout << MinCostFlow(source, sink, n, &graph) << endl;
  }
  return 0;
}
```

